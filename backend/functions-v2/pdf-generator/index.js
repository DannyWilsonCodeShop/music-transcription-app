// Lambda: PDF Generator
// Generates PDF with chords and lyrics using jsPDF

const { S3Client, PutObjectCommand } = require('@aws-sdk/client-s3');
const { DynamoDBClient } = require('@aws-sdk/client-dynamodb');
const { DynamoDBDocumentClient, GetCommand, UpdateCommand } = require('@aws-sdk/lib-dynamodb');
const { jsPDF } = require('jspdf');

const s3Client = new S3Client({});
const dynamoClient = new DynamoDBClient({});
const docClient = DynamoDBDocumentClient.from(dynamoClient);

const JOBS_TABLE = process.env.DYNAMODB_JOBS_TABLE;
const PDF_BUCKET = process.env.S3_PDF_BUCKET;

exports.handler = async (event) => {
  console.log('Event:', JSON.stringify(event, null, 2));
  
  try {
    const { jobId } = event;
    
    // Update status
    await updateJobStatus(jobId, 'GENERATING_PDF', 90);
    
    // Get job data from DynamoDB
    const getResult = await docClient.send(new GetCommand({
      TableName: JOBS_TABLE,
      Key: { jobId }
    }));
    
    const job = getResult.Item;
    if (!job) {
      throw new Error('Job not found');
    }
    
    const { lyricsData, chordsData, videoTitle } = job;
    
    if (!lyricsData) {
      throw new Error('Missing lyrics data');
    }
    
    console.log('Generating PDF...');
    console.log('Has chords:', !!chordsData);
    
    // Generate PDF (with or without chords)
    const pdfBuffer = await generatePDF(videoTitle, lyricsData, chordsData || null);
    
    // Upload to S3
    const pdfKey = `pdfs/${jobId}.pdf`;
    await s3Client.send(new PutObjectCommand({
      Bucket: PDF_BUCKET,
      Key: pdfKey,
      Body: pdfBuffer,
      ContentType: 'application/pdf',
      Metadata: {
        jobId,
        videoTitle: videoTitle || 'Unknown'
      }
    }));
    
    const pdfUrl = `https://${PDF_BUCKET}.s3.amazonaws.com/${pdfKey}`;
    
    // Update job as complete
    await docClient.send(new UpdateCommand({
      TableName: JOBS_TABLE,
      Key: { jobId },
      UpdateExpression: 'SET pdfS3Key = :key, pdfUrl = :url, #status = :status, progress = :progress, completedAt = :completed, updatedAt = :updated',
      ExpressionAttributeNames: { '#status': 'status' },
      ExpressionAttributeValues: {
        ':key': pdfKey,
        ':url': pdfUrl,
        ':status': 'COMPLETE',
        ':progress': 100,
        ':completed': new Date().toISOString(),
        ':updated': new Date().toISOString()
      }
    }));
    
    console.log('PDF generated successfully:', pdfUrl);
    
    return {
      statusCode: 200,
      body: {
        jobId,
        pdfUrl,
        pdfKey
      }
    };
    
  } catch (error) {
    console.error('Error:', error);
    await updateJobStatus(event.jobId, 'FAILED', 0, error.message);
    
    return {
      statusCode: 500,
      body: { error: error.message }
    };
  }
};

async function generatePDF(title, lyricsData, chordsData) {
  const doc = new jsPDF();
  
  // Title
  doc.setFontSize(20);
  doc.setFont('helvetica', 'bold');
  doc.text(title || 'Untitled', 20, 20);
  
  // Key signature (if chords available)
  if (chordsData && chordsData.key) {
    doc.setFontSize(12);
    doc.setFont('helvetica', 'normal');
    doc.text(`Key: ${chordsData.key}`, 20, 30);
  }
  
  let yPos = 45;
  const pageHeight = doc.internal.pageSize.height;
  const marginBottom = 20;
  
  // Combine lyrics and chords (or just format lyrics)
  const combined = chordsData ? combineLyricsAndChords(lyricsData, chordsData) : formatLyricsOnly(lyricsData);
  
  doc.setFontSize(11);
  
  for (const section of combined) {
    // Check if we need a new page
    if (yPos > pageHeight - marginBottom) {
      doc.addPage();
      yPos = 20;
    }
    
    // Draw chord above lyrics
    if (section.chord && section.chord !== 'N') {
      doc.setFont('helvetica', 'bold');
      doc.setTextColor(0, 100, 200);
      doc.text(section.chord, 20, yPos);
      yPos += 5;
    }
    
    // Draw lyrics
    doc.setFont('helvetica', 'normal');
    doc.setTextColor(0, 0, 0);
    
    const lines = doc.splitTextToSize(section.text, 170);
    for (const line of lines) {
      if (yPos > pageHeight - marginBottom) {
        doc.addPage();
        yPos = 20;
      }
      doc.text(line, 20, yPos);
      yPos += 6;
    }
    
    yPos += 4; // Extra space between sections
  }
  
  // Footer
  doc.setFontSize(8);
  doc.setTextColor(128, 128, 128);
  doc.text('Generated by ChordScout', 20, pageHeight - 10);
  
  return Buffer.from(doc.output('arraybuffer'));
}

function combineLyricsAndChords(lyricsData, chordsData) {
  const combined = [];
  const chords = chordsData.chords || [];
  const paragraphs = lyricsData.paragraphs || [];
  
  if (paragraphs.length === 0) {
    // Fallback: split lyrics by lines
    const lines = (lyricsData.text || '').split('\n');
    let chordIndex = 0;
    
    for (const line of lines) {
      if (line.trim()) {
        const chord = chordIndex < chords.length ? chords[chordIndex].chord : null;
        combined.push({
          text: line,
          chord: chord
        });
        chordIndex++;
      }
    }
  } else {
    // Match chords to paragraphs by timestamp
    for (const para of paragraphs) {
      const matchingChords = chords.filter(c => 
        c.start >= para.start && c.start < para.end
      );
      
      if (matchingChords.length > 0) {
        // Group chords for this paragraph
        const chordNames = matchingChords.map(c => c.chord).filter(c => c !== 'N');
        const chordStr = chordNames.length > 0 ? chordNames.join(' - ') : null;
        
        combined.push({
          text: para.text,
          chord: chordStr
        });
      } else {
        combined.push({
          text: para.text,
          chord: null
        });
      }
    }
  }
  
  return combined;
}

function formatLyricsOnly(lyricsData) {
  const formatted = [];
  const paragraphs = lyricsData.paragraphs || [];
  
  if (paragraphs.length === 0) {
    // Fallback: split lyrics by lines
    const lines = (lyricsData.text || '').split('\n');
    for (const line of lines) {
      if (line.trim()) {
        formatted.push({
          text: line,
          chord: null
        });
      }
    }
  } else {
    for (const para of paragraphs) {
      formatted.push({
        text: para.text,
        chord: null
      });
    }
  }
  
  return formatted;
}

async function updateJobStatus(jobId, status, progress, error = null) {
  const updateExpr = error
    ? 'SET #status = :status, progress = :progress, errorMessage = :error, updatedAt = :updated'
    : 'SET #status = :status, progress = :progress, updatedAt = :updated';
  
  const exprValues = {
    ':status': status,
    ':progress': progress,
    ':updated': new Date().toISOString()
  };
  
  if (error) {
    exprValues[':error'] = error;
  }
  
  await docClient.send(new UpdateCommand({
    TableName: JOBS_TABLE,
    Key: { jobId },
    UpdateExpression: updateExpr,
    ExpressionAttributeNames: { '#status': 'status' },
    ExpressionAttributeValues: exprValues
  }));
}
