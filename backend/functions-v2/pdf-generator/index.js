// Lambda: PDF Generator
// Generates PDF with chords and lyrics using jsPDF

const { S3Client, PutObjectCommand } = require('@aws-sdk/client-s3');
const { DynamoDBClient } = require('@aws-sdk/client-dynamodb');
const { DynamoDBDocumentClient, GetCommand, UpdateCommand } = require('@aws-sdk/lib-dynamodb');
const { jsPDF } = require('jspdf');

const s3Client = new S3Client({});
const dynamoClient = new DynamoDBClient({});
const docClient = DynamoDBDocumentClient.from(dynamoClient);

const JOBS_TABLE = process.env.DYNAMODB_JOBS_TABLE;
const PDF_BUCKET = process.env.S3_PDF_BUCKET;

exports.handler = async (event) => {
  console.log('Event:', JSON.stringify(event, null, 2));
  
  try {
    const { jobId } = event;
    
    // Update status
    await updateJobStatus(jobId, 'GENERATING_PDF', 90);
    
    // Get job data from DynamoDB
    const getResult = await docClient.send(new GetCommand({
      TableName: JOBS_TABLE,
      Key: { jobId }
    }));
    
    const job = getResult.Item;
    if (!job) {
      throw new Error('Job not found');
    }
    
    const { lyricsData, chordsData, videoTitle } = job;
    
    if (!lyricsData) {
      throw new Error('Missing lyrics data');
    }
    
    console.log('Generating PDF...');
    console.log('Has chords:', !!chordsData);
    
    // Generate PDF (with or without chords)
    const pdfBuffer = await generatePDF(videoTitle, lyricsData, chordsData || null);
    
    // Upload to S3
    const pdfKey = `pdfs/${jobId}.pdf`;
    await s3Client.send(new PutObjectCommand({
      Bucket: PDF_BUCKET,
      Key: pdfKey,
      Body: pdfBuffer,
      ContentType: 'application/pdf',
      Metadata: {
        jobId,
        videoTitle: videoTitle || 'Unknown'
      }
    }));
    
    const pdfUrl = `https://${PDF_BUCKET}.s3.amazonaws.com/${pdfKey}`;
    
    // Update job as complete
    await docClient.send(new UpdateCommand({
      TableName: JOBS_TABLE,
      Key: { jobId },
      UpdateExpression: 'SET pdfS3Key = :key, pdfUrl = :url, #status = :status, progress = :progress, completedAt = :completed, updatedAt = :updated',
      ExpressionAttributeNames: { '#status': 'status' },
      ExpressionAttributeValues: {
        ':key': pdfKey,
        ':url': pdfUrl,
        ':status': 'COMPLETE',
        ':progress': 100,
        ':completed': new Date().toISOString(),
        ':updated': new Date().toISOString()
      }
    }));
    
    console.log('PDF generated successfully:', pdfUrl);
    
    return {
      statusCode: 200,
      body: {
        jobId,
        pdfUrl,
        pdfKey
      }
    };
    
  } catch (error) {
    console.error('Error:', error);
    await updateJobStatus(event.jobId, 'FAILED', 0, error.message);
    
    return {
      statusCode: 500,
      body: { error: error.message }
    };
  }
};

async function generatePDF(title, lyricsData, chordsData) {
  const doc = new jsPDF();
  
  // Title
  doc.setFontSize(20);
  doc.setFont('helvetica', 'bold');
  doc.text(title || 'Untitled', 20, 20);
  
  // Key signature (if chords available)
  if (chordsData && chordsData.key) {
    doc.setFontSize(14);
    doc.setFont('helvetica', 'bold');
    doc.text(`Key: ${chordsData.key} ${chordsData.mode || ''}`, 20, 35);
  }
  
  let yPos = 50;
  const pageHeight = doc.internal.pageSize.height;
  const marginBottom = 20;
  const staffHeight = 25;
  const chordSpacing = 40;
  
  // Combine lyrics and chords with Nashville numbers
  const combined = chordsData ? combineLyricsAndChords(lyricsData, chordsData) : formatLyricsOnly(lyricsData);
  
  for (const section of combined) {
    // Check if we need a new page
    if (yPos > pageHeight - marginBottom - staffHeight - 40) {
      doc.addPage();
      yPos = 20;
    }
    
    // Draw lyrics first
    doc.setFontSize(12);
    doc.setFont('helvetica', 'normal');
    doc.setTextColor(0, 0, 0);
    
    const lines = doc.splitTextToSize(section.text, 170);
    for (const line of lines) {
      if (yPos > pageHeight - marginBottom - staffHeight - 40) {
        doc.addPage();
        yPos = 20;
      }
      doc.text(line, 20, yPos);
      yPos += 6;
    }
    
    yPos += 8; // Space before staff
    
    // Draw chord staff with Nashville numbers if chords exist
    if (section.chords && section.chords.length > 0) {
      drawChordStaff(doc, section.chords, chordsData.key, 20, yPos, 170);
      yPos += staffHeight + 15;
    }
    
    yPos += 10; // Extra space between sections
  }
  
  // Footer
  doc.setFontSize(8);
  doc.setTextColor(128, 128, 128);
  doc.text('Generated by ChordScout - Nashville Number System', 20, pageHeight - 10);
  
  return Buffer.from(doc.output('arraybuffer'));
}

function drawChordStaff(doc, chords, key, x, y, width) {
  const staffLines = 5;
  const lineSpacing = 3;
  const chordSpacing = width / Math.max(chords.length, 4);
  
  // Draw staff lines
  doc.setLineWidth(0.5);
  doc.setDrawColor(0, 0, 0);
  
  for (let i = 0; i < staffLines; i++) {
    const lineY = y + (i * lineSpacing);
    doc.line(x, lineY, x + width, lineY);
  }
  
  // Draw chords and Nashville numbers
  doc.setFontSize(10);
  doc.setFont('helvetica', 'bold');
  
  chords.forEach((chord, index) => {
    const chordX = x + (index * chordSpacing) + 10;
    
    // Draw chord name above staff
    doc.setTextColor(0, 100, 200);
    doc.text(chord, chordX, y - 5);
    
    // Calculate and draw Nashville number below staff
    const nashvilleNumber = getNashvilleNumber(chord, key);
    doc.setTextColor(200, 0, 0);
    doc.setFont('helvetica', 'bold');
    doc.text(nashvilleNumber, chordX, y + (staffLines * lineSpacing) + 8);
  });
}

function getNashvilleNumber(chord, key) {
  // Nashville Number System mapping
  const majorScale = ['C', 'D', 'E', 'F', 'G', 'A', 'B'];
  const minorScale = ['A', 'B', 'C', 'D', 'E', 'F', 'G'];
  
  // Parse chord to get root note
  let rootNote = chord.replace(/[^A-G#b]/g, '');
  if (rootNote.length > 1 && rootNote[1] === '#') {
    rootNote = rootNote.substring(0, 2);
  } else if (rootNote.length > 1 && rootNote[1] === 'b') {
    rootNote = rootNote.substring(0, 2);
  } else {
    rootNote = rootNote[0];
  }
  
  // Parse key to get tonic
  let keyRoot = key.replace(/[^A-G#b]/g, '');
  if (keyRoot.length > 1 && (keyRoot[1] === '#' || keyRoot[1] === 'b')) {
    keyRoot = keyRoot.substring(0, 2);
  } else {
    keyRoot = keyRoot[0];
  }
  
  // Determine if key is major or minor
  const isMinor = key.toLowerCase().includes('m') || key.toLowerCase().includes('minor');
  
  // Convert notes to semitones for calculation
  const noteToSemitone = {
    'C': 0, 'C#': 1, 'Db': 1, 'D': 2, 'D#': 3, 'Eb': 3, 'E': 4, 'F': 5,
    'F#': 6, 'Gb': 6, 'G': 7, 'G#': 8, 'Ab': 8, 'A': 9, 'A#': 10, 'Bb': 10, 'B': 11
  };
  
  const keySemitone = noteToSemitone[keyRoot] || 0;
  const chordSemitone = noteToSemitone[rootNote] || 0;
  
  // Calculate interval
  let interval = (chordSemitone - keySemitone + 12) % 12;
  
  // Map to Nashville numbers
  const majorNumbers = ['1', 'b2', '2', 'b3', '3', '4', 'b5', '5', 'b6', '6', 'b7', '7'];
  const minorNumbers = ['1', 'b2', 'b3', '3', '4', 'b5', '5', 'b6', '6', 'b7', '7', '7'];
  
  let number = isMinor ? minorNumbers[interval] : majorNumbers[interval];
  
  // Add chord quality indicators
  if (chord.includes('m') && !chord.includes('maj')) {
    // Minor chord - use lowercase if it's not the relative minor
    if (!isMinor || interval !== 0) {
      number = number.toLowerCase();
    }
  }
  
  if (chord.includes('7')) {
    number += '7';
  }
  if (chord.includes('maj7')) {
    number = number.replace('7', 'maj7');
  }
  if (chord.includes('dim')) {
    number += 'Â°';
  }
  if (chord.includes('aug') || chord.includes('+')) {
    number += '+';
  }
  
  return number;
}

function combineLyricsAndChords(lyricsData, chordsData) {
  const combined = [];
  const chords = chordsData.chords || [];
  const paragraphs = lyricsData.paragraphs || [];
  
  if (paragraphs.length === 0) {
    // Fallback: split lyrics by lines and group chords
    const lines = (lyricsData.text || '').split('\n');
    let chordIndex = 0;
    const chordsPerLine = 4; // Group chords in sets of 4
    
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      if (line.trim()) {
        // Get chords for this line
        const lineChords = [];
        for (let j = 0; j < chordsPerLine && chordIndex < chords.length; j++) {
          lineChords.push(chords[chordIndex].chord || chords[chordIndex].name);
          chordIndex++;
        }
        
        combined.push({
          text: line,
          chords: lineChords.filter(c => c && c !== 'N')
        });
      }
    }
  } else {
    // Match chords to paragraphs by timestamp
    for (const para of paragraphs) {
      const matchingChords = chords.filter(c => 
        c.start >= para.start && c.start < para.end
      );
      
      const chordNames = matchingChords
        .map(c => c.chord || c.name)
        .filter(c => c && c !== 'N')
        .slice(0, 6); // Limit to 6 chords per section
      
      combined.push({
        text: para.text,
        chords: chordNames
      });
    }
  }
  
  return combined;
}

function formatLyricsOnly(lyricsData) {
  const formatted = [];
  const paragraphs = lyricsData.paragraphs || [];
  
  if (paragraphs.length === 0) {
    // Fallback: split lyrics by lines
    const lines = (lyricsData.text || '').split('\n');
    for (const line of lines) {
      if (line.trim()) {
        formatted.push({
          text: line,
          chords: []
        });
      }
    }
  } else {
    for (const para of paragraphs) {
      formatted.push({
        text: para.text,
        chords: []
      });
    }
  }
  
  return formatted;
}

async function updateJobStatus(jobId, status, progress, error = null) {
  const updateExpr = error
    ? 'SET #status = :status, progress = :progress, errorMessage = :error, updatedAt = :updated'
    : 'SET #status = :status, progress = :progress, updatedAt = :updated';
  
  const exprValues = {
    ':status': status,
    ':progress': progress,
    ':updated': new Date().toISOString()
  };
  
  if (error) {
    exprValues[':error'] = error;
  }
  
  await docClient.send(new UpdateCommand({
    TableName: JOBS_TABLE,
    Key: { jobId },
    UpdateExpression: updateExpr,
    ExpressionAttributeNames: { '#status': 'status' },
    ExpressionAttributeValues: exprValues
  }));
}
